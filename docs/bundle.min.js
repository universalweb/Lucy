!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).$=e()}(this,(function(){"use strict";let t;const e=(...e)=>t(...e);e.superMethod=e=>{t=e};const n=Object,r=n.keys,s=n.is,c=n.assign,o=n.getOwnPropertyDescriptor,a=n.defineProperty,i=n.getOwnPropertyNames,l=t=>r(t).length;c(e,{assign:c,defineProperty:a,getOwnPropertyDescriptor:o,getOwnPropertyNames:i,is:s,keys:r,objectSize:l});const u=Array.from;c(e,{toArray:u});const p=Reflect.apply;c(e,{apply:p});const h=function(t){return void 0===t},g=t=>null===t,f=t=>!h(t)&&!g(t),y=t=>e=>!!f(e)&&e.constructor===t,m=/\.|\+/,d=Array.isArray,A=y(String),b=y(Number),w=t=>!!f(t)&&"Object("===t.constructor.toString().trim().slice(9,16),O=t=>!!f(t)&&t instanceof Function,j=t=>Boolean(t.length),v=t=>e=>!!f(e)&&t.test(e),S=v(/\.css$/),k=v(/\.json$/),M=v(/\.js$/),R=v(/\.html$/),C=v(/\./),F=/\.([0-9a-z]+)/;c(e,{getFileExtension:t=>{const e=t.match(F);if(e)return e[1]},has:(t,...e)=>t.includes(...e),hasDot:C,hasLength:j,hasValue:f,isArray:d,isBoolean:t=>"Boolean"===t.constructor.name,isDate:t=>t instanceof Date,isDecimal:t=>m.test(t.toString()),isEmpty:t=>A(t)||d(t)?!j(t):w(t)?!l(t):!f(t),isFileCSS:S,isFileHTML:R,isFileJS:M,isFileJSON:k,isFunction:O,isNull:g,isNumber:b,isPlainObject:w,isRegExp:t=>t instanceof RegExp,isString:A,isUndefined:h});const x=(t,e)=>{const n=t.length;for(let r=0;r<n;r++)e(t[r],r,t,n);return t},E=(t,e)=>{const n=t.length;for(let r=n-1;r>=0;r--)e(t[r],r,t,n);return t},I=(t,e)=>{const n=t.length;for(let r=0;r<n;r++)if(!1===e(t[r],r,t,n))return!1;return!0},N=(t,e,n=[])=>(x(t,((t,r,s,c)=>{!0===e(t,r,n,s,c)&&n.push(t)})),n),U=(T=x,(t,e,n=[])=>(T(t,((t,r,s,c)=>{n[r]=e(t,r,n,s,c)})),n));var T;const $=(t,e,n=[])=>(x(t,((t,r,s,c)=>{const o=e(t,r,n,s,c);f(o)&&n.push(o)})),n);c(e,{compactMapArray:$,eachArray:x,eachArrayRight:E,filterArray:N,mapArray:U,mapArrayRight:(t,e,n=[])=>{let r=0;const s=t.length;for(let c=s-1;c>=0;c--)n[r]=e(t[c],c,t,s),r++;return n},mapWhile:(t,e,n=[])=>{const r=t.length;for(let s=0;s<r;s++){const c=e(t[s],s,n,t,r);if(!1===c)break;n[s]=c}return n},whileArray:I});x(["Arguments","Map","Set","WeakMap"],(t=>{var n;e[`is${t}`]=(n=`[object ${t}]`,t=>!!f(t)&&t.toString()===n)}));x(["ArrayBuffer","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array"],(t=>{e[`is${t}`]=e=>!!f(e)&&e.constructor.name===t}));c(e,{asyncEach:async(t,e)=>{const n=t.length;for(let r=0;r<n;r++){const s=t[r];await s(e,r,t,n)}return t}});const L=t=>d(t)?t:[t];c(e,{ensureArray:L});const P=t=>t.flat(1/0);c(e,{flatten:(t,e=1)=>{let n=t;for(let t=0;t<e;t++)n=n.reduce(((t,e)=>t.concat(L(e))),[]);return n},flattenDeep:P});c(e,{remove:(t,e)=>{let n=t.length;for(let r=0;r<n;r++){const s=t[r];e.includes(s)&&(t.splice(r,1),r--,n--)}return t},removeBy:(t,e)=>{let n=t.length;for(let r=0;r<n;r++){e(t[r],r)&&(t.splice(r,1),r--,n--)}return t}});c(e,{chunk:(t,e=1)=>{const n=[];let r=0;return t.forEach(((t,s)=>{s%e||(n.push([]),s&&r++),n[r].push(t)})),n}});c(e,{rest:t=>t.slice(1,t.length)});const B=t=>(t.length=0,t);c(e,{clear:B});c(e,{right:(t,e)=>t[t.length-1-e]});c(e,{cloneArray:t=>t.slice()});const D=Math,z=D.floor,q=D.random,K=(t,e=0)=>z(q()*(t-e))+e;c(e,{add:(t,e)=>t+e,deduct:t=>t-1,divide:(t,e)=>t/e,increment:t=>t+1,minus:(t,e)=>t-e,multiply:(t,e)=>t*e,randomArbitrary:(t,e=0)=>q()*(t-e)+e,randomInt:K,remainder:(t,e)=>t%e});const W=(t,e=t.length)=>{if(t.length<=1)return u(t);const n=u(t);let r,s,c=0;for(;c<e;)r=K(n.length-1,0),s=n[c],n[c]=n[r],n[r]=s,c++;return n};c(e,{shuffle:W});c(e,{sample:(t,e=1)=>{if(!t)return!1;const n=t.length;if(n===e||e>n)return W(t);if(1===e)return[t[K(n-1,0)]];const r=[],s={};let c,o=0;for(;o<e;)c=K(t.length-1,0),s[c]||(r.push(t[c]),s[c]=!0,o++);return r}});c(e,{compact:t=>t.filter((t=>!(A(t)&&!t.length)&&t))});c(e,{initial:t=>t.slice(0,t.length-1)});const J=Math.min;c(e,{smallest:t=>J(...t)});c(e,{range:(t,e,n=1)=>t<e?((t,e,n)=>{const r=[];let s=t;for(;s<e;)r.push(s),s+=n;return r})(t,e,n):((t,e,n)=>{const r=n<0?-1*n:n,s=[];let c=t;for(;c>e;)s.push(c),c-=r;return s})(t,e,n)});c(e,{intersect:(t,...e)=>$(t,(t=>{if(I(e,(e=>e.includes(t))))return t}))});c(e,{difference:(t,...e)=>{const n=P(e);return $(t,(t=>{if(!n.includes(t))return t}))}});const Z=(t,e,n=t.length)=>t.splice(e,n);c(e,{drop:Z,dropRight:(t,e,n=t.length)=>Z(t,0,n-e)});const V=(t,e)=>t.length===e.length&&I(t,((t,n)=>e[n]===t));c(e,{isMatchArray:V});c(e,{sortedIndex:(t,e)=>{let n=0;return I(t,((t,r)=>(n=r,e>t))),n}});const _=Math.max;c(e,{largest:t=>_(...t)});c(e,{sum:t=>t.reduce(((t,e)=>t+e),0)});const H=async(t,e)=>{const n=t.length;for(let r=0;r<n;r++)await e(t[r],r,t,n);return t},G=async(t,e)=>{const n=t.length;for(let r=n-1;r>=0;r--)await e(t[r],r,t,n);return t};c(e,{eachAsync:H,eachAsyncRight:G});c(e,{last:(t,e)=>{const n=t.length;return e?t.slice(n-e,n):t[n-1]}});c(e,{take:(t,e=1)=>t.slice(0,e),takeRight:(t,e=1)=>{const n=t.length;return t.slice(n-e,n)}});const Q=async(t,e)=>{const n=[];return await H(t,(async(t,r,s)=>{n[r]=await e(t,r,s)})),n};c(e,{mapAsync:Q});const X=(t,e,n)=>n.indexOf(t)===e,Y=(t,e,n)=>t!==n[e-1],tt=(t,e)=>e?t.filter(Y):t.filter(X);c(e,{unique:tt});c(e,{union:(...t)=>tt(P(t))});c(e,{compactMapAsync:async(t,e)=>{const n=[];let r;return await H(t,(async(t,s,c)=>{r=await e(t,s,n,c),f(r)&&n.push(r)})),n}});const et=(t,e)=>t-e;c(e,{numSort:t=>t.sort(et)});c(e,{arrayToObject:(t,e)=>{const n={};return x(t,((t,r)=>{n[e[r]]=t})),n}});c(e,{without:(t,e)=>t.filter((t=>!e.includes(t)))});c(e,{partition:(t,e)=>{const n=[];return[$(t,(t=>{if(e(t))return t;n.push(t)})),n]}});c(e,{xor:(...t)=>{const e=[];return x(t,(t=>{x(tt(t),(t=>{e.includes(t)?e.splice(e.indexOf(t),1):e.push(t)}))})),e}});c(e,{unZip:t=>t[0].map(((e,n)=>t.map((t=>t[n])))),zip:(...t)=>t[0].map(((e,n)=>t.map((t=>t[n]))))});c(e,{first:(t,e)=>e?t.slice(0,e):t[0]});const nt=(t,e)=>e-t;c(e,{rNumSort:t=>t.sort(nt)});const rt=(t,e,n)=>{const r=n?t:0,s=n?e:t,c=n||e;for(let t=r;t<s;t++)c(t,r,s)};c(e,{times:rt,timesMap:(t,e,n,r=[])=>{const s=n?t:0,c=n?e:t,o=n||e;let a;return rt(s,c,(t=>{a=o(t,s,c,r),f(a)&&r.push(a)})),r}});const st=(t,e,n=!0)=>(n?t:[...t]).sort(((t,n)=>n[e]?t[e]?t[e]<n[e]?1:t[e]>n[e]?-1:0:1:-1));c(e,{getNewest:(t,e)=>st(t,e,!1)[0],sortNewest:st});const ct=(t,e="id",n=!0)=>(n?t:[...t]).sort(((t,n)=>n[e]?t[e]?t[e]<n[e]?-1:t[e]>n[e]?1:0:-1:1));c(e,{getOldest:(t,e="id")=>ct(t,e)[0],sortOldest:ct});c(e,{groupBy:(t,e)=>{const n={};return x(t,(t=>{const r=e(t);n[r]||(n[r]=[]),n[r].push(t)})),n}});c(e,{countBy:(t,e)=>{const n={};let r;return x(t,(t=>{r=e(t),n[r]||(n[r]=0),n[r]++})),n},countKey:(t,e)=>{let n=0;return x(t,(t=>{t[e]&&n++})),n},countWithoutKey:(t,e)=>{let n=0;return x(t,(t=>{t[e]||n++})),n}});c(e,{indexBy:(t,e="id")=>{const n={};return x(t,(t=>{n[t[e]]=t})),n}});c(e,{pluck:(t,e)=>U(t,(t=>t[e]))});const ot=(t,e)=>U(e,(e=>t[e]));c(e,{pluckObject:ot});c(e,{pluckValues:(t,e)=>U(t,(t=>ot(t,e)))});c(e,{invoke:(t,e,n)=>U(t,((t,r)=>t[e](n,r)))});c(e,{invokeAsync:(t,e,n)=>Q(t,(async(t,r)=>t[e](n,r)))});const at=(t,e,n,r,s)=>{if(t[s]===r)return!0};c(e,{findIndex:(t,e,n="id")=>{const r=t.findIndex(((t,r)=>at(t,0,0,e,n)));return-1!==r&&r},findItem:(t,e,n="id")=>{const r=t.find(((t,r)=>at(t,0,0,e,n)));return-1!==r&&r}});c(e,{sortAlphabetical:(t,e)=>t.sort(((t,n)=>{const r=t[e],s=n[e];return r<s?-1:r>s?1:0}))});c(e,{ary:(t,e)=>(...n)=>t(...n.splice(0,e))});c(e,{curry:(t,e=t.length)=>{const n=[],r=(...s)=>{if(n.push(...s),n.length===e){const e=t(...n);return B(n),e}return r};return r},curryRight:(t,e=t.length)=>{const n=[],r=(...s)=>{if(n.unshift(...s),n.length===e){const e=t(...n);return B(n),e}return r};return r}});c(e,{after:(t,e)=>{let n,r=t;return(...t)=>(null!==r&&r--,r<=0&&(n=e(...t),r=null),n)},before:(t,e)=>{let n,r=t;return(...t)=>(null!==r&&r--,r>=1?n=e(...t):r=null,n)},once:t=>{let e;return(...n)=>(f(e)||(e=t(...n)),e)}});c(e,{noop:()=>{},stubArray:()=>[],stubFalse:()=>!1,stubObject:()=>({}),stubString:()=>"",stubTrue:()=>!0});const it=(t,e)=>{const n=r(t);x(n,((r,s,c,o)=>{e(t[r],r,t,o,n)}))},lt=(t,e)=>{const n=r(t);return I(n,((n,r,s,c)=>e(t[n],n,t,c,s)))},ut=(t,e,n={})=>(it(t,((t,r,s,c,o)=>{!0===e(t,r,n,s,c,o)&&(n[r]=t)})),n),pt=(t,e,n={})=>(it(t,((t,r,s,c,o)=>{n[r]=e(t,r,n,s,c,o)})),n),ht=(t,e,n={})=>(it(t,((t,r,s,c,o)=>{const a=e(t,r,n,c,o);f(a)&&(n[r]=a)})),n);c(e,{compactMapObject:ht,eachObject:it,filterObject:ut,mapObject:pt,whileObject:lt});const gt=(t,e)=>t.forEach(e),ft=(t,e)=>(n,r,s)=>{let c;if(f(n))return c=d(n)?t:w(n)||O(n)?e:n.forEach?gt:e,c(n,r,s)},yt=ft(I,lt),mt=ft(x,it),dt=ft(N,ut),At=ft(U,pt),bt=ft($,ht);c(e,{compactMap:bt,each:mt,eachWhile:yt,filter:dt,map:At});c(e,{bindAll:(t,e)=>At(t,(t=>O(t)?t.bind(e):t))});c(e,{ifInvoke:(t,...e)=>{if(O(t))return t(...e)}});c(e,{negate:t=>(...e)=>!t(...e)});c(e,{every:yt});c(e,{over:t=>(...e)=>At(t,(t=>t(...e))),overEvery:t=>(...e)=>yt(t,(t=>t(...e)))});const wt=(t,e)=>setTimeout(t,e),Ot=(t,e)=>setInterval(t,e),jt=(t,e)=>()=>{rt(0,t((()=>{}),0),(t=>{e(t)}))},vt=jt(wt,clearTimeout),St=jt(Ot,clearInterval);c(e,{clearIntervals:St,clearTimers:vt,debounce:(t,e)=>{let n=!1;const r=(...r)=>{!1!==n&&clearTimeout(n),n=wt((()=>{t(...r),n=!1}),e)};return r.clear=()=>{n&&(clearTimeout(n),n=!1)},r},interval:Ot,throttle:(t,e)=>{let n,r=!1;const s=(...s)=>{r?n=!0:(t(...s),r=wt((()=>{n&&t(...s),r=!1}),e))};return s.clear=()=>{clearTimeout(r),r=!1},s},timer:wt});c(e,{chain:t=>{const e=t=>(e.value=t,e.methods);return c(e,{add:t=>((t,e)=>(mt(e,((e,n)=>{t.methods[n]=(...n)=>(e(t.value,...n),t.methods)})),t))(e,t),done(){const t=e.value;return e.value=null,t},methods:{}}),e.add(t),e}});c(e,{inAsync:async(t,e)=>H(t,(async t=>{await t(e)})),inSync:(t,e)=>mt(t,(t=>{t(e)}))});c(e,{nthArg:(t=0)=>(...e)=>e[t]});c(e,{reArg:(t,e)=>(...n)=>t(...e.map((t=>n[t])))});c(e,{wrap:(t,e)=>(...n)=>e(t,...n)});c(e,{isNumberEqual:(t,e)=>t===e,isNumberInRange:(t,e,n)=>t>e&&t<n,isZero:t=>0===t});const kt=(t,e)=>{const n=r(t);return I(e,(t=>n.includes(t)))};c(e,{hasAnyKeys:(t,e)=>{const n=r(t);return Boolean(e.find((t=>n.includes(t))))},hasKeys:kt});c(e,{pick:(t,e,n={})=>(x(e,(e=>{n[e]=t[e]})),n)});c(e,{compactKeys:t=>{const e=[];return it(t,((t,n)=>{t&&e.push(n)})),e}});c(e,{isMatchObject:(t,e)=>{const n=r(t);return!!V(n,r(e))&&I(n,(n=>t[n]===e[n]))}});c(e,{unZipObject:t=>{const e=[],n=[];return it(t,((t,r)=>{e.push(r),n.push(t)})),[e,n]},zipObject:(t,e)=>{const n={};return x(t,((t,r)=>{n[t]=e[r]})),n}});c(e,{invert:(t,e={})=>(it(t,((t,n)=>{e[t]=n})),e)});c(e,{omit:(t,e)=>ut(t,((t,n)=>!e.includes(n)))});const Mt=async(t,e)=>{const n=r(t);return await H(n,((r,s,c,o)=>e(t[r],r,t,o,n))),t};c(e,{eachObjectAsync:Mt});c(e,{compactMapObjectAsync:async(t,e,n={})=>(await Mt(t,(async(t,r,s,c,o)=>{const a=await e(t,r,n,c,o);f(a)&&(n[r]=a)})),n),mapObjectAsync:async(t,e,n={})=>(await Mt(t,(async(t,r,s,c,o)=>{n[r]=await e(t,r,n,s,c,o)})),n)});const Rt=/[-_]/g,Ct=/ (.)/g;c(e,{camelCase:t=>t.toLowerCase().replace(Ct,(t=>t.toUpperCase().replace(/ /g,""))),kebabCase:t=>t.replace(Rt," ").trim().toLowerCase().replace(Ct,"-$1"),snakeCase:t=>t.replace(Rt," ").trim().toLowerCase().replace(Ct,"_$1"),upperCase:t=>t.replace(Rt," ").trim().toUpperCase()});const Ft=(t,e=1)=>t.substr(e);c(e,{chunkString:(t,e)=>t.match(new RegExp(`(.|[\r\n]){1,${e}}`,"g")),initialString:(t,e=1)=>t.slice(0,-1*e),insertInRange:(t,e,n)=>t.slice(0,e)+n+t.slice(e,t.length),restString:Ft,rightString:(t,e=1)=>t[t.length-e]});c(e,{replaceList:(t,e,n)=>t.replace(new RegExp("\\b"+e.join("|")+"\\b","gi"),n)});const xt=/%(?![\da-f]{2})/gi,Et=/&/g,It=/</g,Nt=/>/g,Ut=/"/g,Tt=t=>decodeURIComponent(t.replace(xt,(()=>"%25"))),$t=t=>t.replace(Et,"&amp;").replace(It,"&lt;").replace(Nt,"&gt;").replace(Ut,"&quot;");c(e,{htmlEntities:$t,rawURLDecode:Tt,sanitize:t=>$t(Tt(t))});const Lt=/\S+/g,Pt=/\w+/g;c(e,{tokenize:t=>t.match(Lt)||[],words:t=>t.match(Pt)||[]});c(e,{truncate:(t,e)=>{const n=t.length;return n>e?((t,e,n)=>{const r=t.split(""),s=r.length;let c,o=n-e;for(;o<s&&o>=0&&(c=r[o]," "!==c);o--);return t.slice(0,o).trim()})(t,e,n):t},truncateRight:(t,e)=>{const n=t.length;return n>e?((t,e,n)=>{const r=t.split(""),s=r.length;let c,o=e;for(;o<s&&o>0&&(c=r[o]," "!==c);o++);return t.substr(o,n).trim()})(t,e,n):t}});const Bt=/ (.)/g,Dt=t=>t[0].toUpperCase(),zt=t=>Dt(t)+Ft(t).toLowerCase();c(e,{upperFirst:t=>Dt(t)+Ft(t),upperFirstAll:t=>t.replace(Bt,(t=>t.toUpperCase())),upperFirstLetter:Dt,upperFirstOnly:zt,upperFirstOnlyAll:t=>zt(t.toLowerCase()).replace(Bt,(t=>t.toUpperCase()))});const qt=(t,e,n=!0)=>(mt(e,((e,r)=>{w(e)&&w(t[r])?qt(t[r],e,n):n&&d(e)&&d(t[r])?t[r].push(...e):t[r]=e})),t);c(e,{assignDeep:qt});const Kt=Function.prototype;c(e,{cacheNativeMethod:function(t){return Kt.call.bind(t)}});c(e,{ifNotEqual:(t,e,n)=>(e&&!f(t[e])&&(t[e]=n),t)});const Wt=(t,e)=>{if(t===e)return!0;if(t.toString()===e.toString())if(w(t)){const n=r(t);if(kt(e,n))return I(n,(n=>Wt(t[n],e[n])))}else if(d(t)&&t.length===e.length)return I(t,((t,n)=>Wt(t,e[n])));return!1};c(e,{isEqual:Wt});c(e,{propertyMatch:(t,e,n=r(t))=>I(n,(n=>Wt(t[n],e[n])))});const Jt=/\.|\[/,Zt=/]/g,Vt=t=>t.replace(Zt,"").split(Jt);c(e,{toPath:Vt});let _t=0;const Ht=[],Gt={},Qt=()=>{let t=Ht.shift(Ht);return f(t)||(t=_t,Gt[t]=!0,_t++),t};Qt.free=t=>{Gt[t]=null,Ht.push(t)},c(e,{uid:Qt});const Xt=(t,n=e)=>{let r=n;return I(Vt(t),(t=>(r=r[t],f(r)))),r};c(e,{get:Xt});const Yt=JSON,te=Yt.parse,ee=Yt.stringify;c(e,{jsonParse:te,stringify:ee});const ne=(t,e)=>(f(e)&&(ne[t]=e),Xt(t,ne));e.superMethod(ne),c(e,{model:ne});c(e,{promise:t=>new Promise(t)});c(e,{toggle:(t,e=!0,n=!1)=>Wt(e,t)?n:e});const re=t=>(...e)=>n=>{let r=n;return t(e,(t=>{r=t(r)})),r},se=re(x),ce=re(E);c(e,{flow:se,flowRight:ce});const oe=t=>(...e)=>async n=>{let r=n;return await t(e,(async t=>{r=await t(r)})),r},ae=oe(H),ie=oe(G);return c(e,{flowAsync:ae,flowAsyncRight:ie}),e}));
